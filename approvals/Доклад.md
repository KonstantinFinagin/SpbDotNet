## Структура выступления

### Введение

Всем привет, меня зовут ---, сейчас я работаю --- , а до этого 8 лет работал в компании --- где на одном из финтех проектов получил опыт, которым бы сегодня хотел с вами поделиться. 

Говорить я сегодня буду на тему юнит тестов, роста их сложности и как с этим бороться при помощи апрувал тестов и форматирования данных в виде таблиц. Тема это скорее уровня джуниор+, так как многие знают, что такое юнит тесты и давно и успешно используют их в работе. Но к моему удивлению, я также встречаю очень много людей на сеньорных и лидовых позициях, кто не знает, что такое апрувалы  и не применяет их на практике. 

Осознание того, что такое юнит-тесты и зачем они нужны, к начинающему программисту приходит обычно одновременно с пониманием принципов Dependency Injection, и пониманием того, что эти две вещи неразрывно связаны. Спустя некоторое время моки и ассерты становятся неотъемлемой частью разработки, и вместе с написанием логики и алгоритмов пишется тест, который становится частью покрытия, гарантией уменьшения технического долга. 

Тесты пишутся обычно в трех случаях:

- У нас есть логика, которую мы хотим протестировать (рефакторинги, легаси, сначала придумали логику)
- У нас еще нет логики которую мы хотим протестировать (TDD-подход)
- Казалось бы протестированная логика упала на проде и мы хотим ее воспроизвести и зафиксировать в тесте (реальная жизнь)

Во всех этих трех случаях неизменной остается структура теста из трех секций:

```csharp
[Fact]
public void Test()
{
	// Arrange
	_service1Mock.When(...).Do(...);
	_service2Mock.When(...).Returns(...);

	// Act
	var outputData = _testedService.DoSomething(inputData);
		// внутри использует _service1Mock, _service2Mock
	
	// Assert
	Assert.Equal("ExpectedValue", outputData.Field1);
	_service1.Received(1).DoSomethingElse();
}
```

Если тестируется какой-то сервис с зависимостями, в секции Arrange производятся настройки моков, их предполагаемый вывод и реакции на входные данные, в секции Act вызывается сам тестируемый метод (при этом в его работе учитываются сетапы секции Arrange), а в Assert пишутся ассерты и верификации, проверяются поля объекта результата.

---

В тривиальных случаях юнит тесты не вызывают проблем. Если что-то становится сложно тестировать, или внутри теста возникает много неявных зависимостей, это может говорить о том, что нужно выделить отдельные операции в другой сервис. 

Однако, иногда это невозможно и рост сложности теста неразрывно связан с ростом сложности самой логики внутри метода. Секция Act обычно остается самой короткой и не меняется. Но секции Arrange и Assert могут расти. Об этом сегодня мы и поговорим. 

### Часть 1. Рост сложности секции Assert и необходимость Approvals

---

#### Сценарий 1. Много ассертов и мы знакомимся с Approval тестами.

Это очень распространенный случай независимо от предметной области. Если наш метод DoSomething из примера 1 возвращает достаточно сложный объект, то секция Assert может расти с ростом количества его пропертей. Например:

```csharp
[Fact]
public void Test()
{
	// Arrange
	var dataReceivedByMock1 = new Data1();

	_service1Mock.When(...).Do(_ => dataReceivedByMock1 = ...);
	_service2Mock.When(...).Return();

	// Act
	var outputData = _testedService.DoSomething(inputData);
	
	// Assert
	Assert.Equal("ExpectedValue1", outputData.Field1);
	Assert.Equal("ExpectedValue2", outputData.Field2);
	...
	Assert.Equal("ExpectedValue51", outputData.Field5.Child1);
	Assert.Equal("ExpectedValue52", outputData.Field6.Child2);
	Assert.Equal("ExpectedValue53", outputData.Field7.Child3);
	
	Assert.Equal("DataReceivedByMock1", dataReceivedByMock1.Field1);
	Assert.Equal("DataReceivedByMock2", dataReceivedByMock1.Field2);
	...
}
```


Это может быть глубоко вложенный иерархический объект с десятками полей с числовыми значениями и категориями, которые для проверки корректности нужно оценивать полностью.

---
Например, в проекте такими объектами были иерархии позиций и финансовых транзакций

```csharp
	public class BasePositionGetResponse
	{
		public string CurrencyCode { get; set; }
		public decimal? Funded { get; set; }
		public decimal? Unfunded { get; set; }
		public decimal? Committed { get; set; }
		public decimal? CashOnCash { get; set; }
		public decimal? FundedPIK { get; set; }
		//...
	}

	public class ExtendedPositionGetResponse : BasePositionGetResponse
	{
		public string DimensionId { get; set; }
		public string DimensionName { get; set; }
		public List<ExtendedPositionGetResponse> 
			ChildPositionsResponses { get; set; }
		public Dictionary<int, BasePositionGetResponse> 
			UnitrancheClassPositions { get; set; }
		//...
	}
```

И этот ответ получается в результате работы одного сервиса:

```csharp
await _positionService.GetPositionsAsync(request);
```

Можно представить себе, сколько ассертов бы понадобилось для того, чтобы верифицировать вывод одного метода для определенного запроса.

---
Но это еще не всё. Предположим, во время работы сервиса, для рассматриваемого кейса также производится логгирование. И мы хотим понимать, залоггировал ли метод необходимую информацию. Для этого обычно вместо ILogger в тесте мы подключаем тестовый логгер, сохраняющий сообщения в список, и анализируем этот список в ассертах при помощи Contains или обращаясь к его элементам. 

```csharp
[Fact]
public void Test()
{
	// Arrange
	var dataReceivedByMock1 = new Data1();

	_service1Mock.When(...).Do(_ => dataReceivedByMock1 = ...);
	_service2Mock.When(...).Return();

	// Act
	var outputData = _testedService.DoSomething(inputData);
		// _testLogger is filled with log messages
	
	// Assert
	Assert.Equal("ExpectedValue1", outputData.Field1);
	Assert.Equal("ExpectedValue2", outputData.Field2);
	...
	Assert.Contains("Data received from service 1", _testLogger.Messages);
	Assert.DoesNotContain("Error retrieving data, retrying", _testLogger.Messages);
	...
}
```

Что будет, если мы пропустим ассерт какого-либо из полей, или объект изменится, и в логику добавится новое поле? Формально, анализ покрытия (cobertura, coverlet и другие инструменты) в этом случае может показывать 100%, так как тест проверяет покрытые строчки кода, но не проверяемое поведение. Это - потенциальное место для бага в будущем.

А как можно проверить все данные одновременно без большого количества ассертов? (вопрос) Сериализовать в json и сравнить строку. Но есть две проблемы - во-первых, при любом отклонении строки от expected значения подсвечиваться будет только самое первое расхождение. А во-вторых, мы должны заранее знать результат и соорудить json.

```csharp
[Fact]
public void Test()
{
	// Arrange
	...
	
	// Act
	var outputData = _testedService.DoSomething(inputData);
	
	// Assert
	var serialized = JsonSerializer.Serialize(outputData, FormattedOptions);
//	var expected = File.ReadAllText("expectedResultPath.json");

	Assert.Equal(expected, serialized);
}
```

### Итого:

- Большие объекты и их иерархии - Много ассертов сложно отслеживать и верифицировать вручную
- Изменения в разработке и статичные тесты - Пропуск добавления полей к объекту
- Верификация сайд-эффектов - логгирование, ретраи и реквесты в сторонние сервисы
- Секция Assert разрастается ее сложнее содержать в актуальном состоянии.

---

Здесь на помощь и приходит аппрувал тестирование (слайд). Еще его называют snapshot-тестированием. Если описать его в двух фразах - то это автоматизация сравнения строк, которые мы получили в результате выполнения теста. При первом прогоне теста в указанной директории создается .received файл, и автоматически запускается diff tool, который присутствует в системе по умолчанию. В нем мы глазами смотрим результат, и если все устраивает, то делаем мердж в .approved файл и сохраняем. 

```
https://github.com/approvals/ApprovalTests.Net
```

```
> dotnet add package ApprovalTests --version 6.0.0
```

```csharp 
[UseReporter(typeof(DiffReporter))]
[UseApprovalSubdirectory("Results")]
public class ApprovalTest
{
	[Fact]
	public void Test()
	{
		// Arrange
		...
		
		// Act
		var outputData = _testedService.DoSomething(inputData);
		
		// Assert
		var serialized = JsonSerializer.Serialize(outputData, FormattedOptions);
		
		// Approval test! 
		Approvals.Verify(serialized);
	}
}
```

После запуска теста, если новый .received файл совпадает с .approved, то тест проходит, если нет, то снова появляется diff tool, где уже подсвчены места расхождения и достаточно зарезолвить конфликты, если новый результат нас устраивает.

При запуске теста в ci cd пайплайне мы, не можем посмотреть diff, и должны использовать так называемый Quiet Reporter.  

Это нужно настроить в тест сетапе в зависимости от среды выполнения, можно сделать это в базовом классе.

```csharp

if (IsCiCdEnvironment())
{
	Approvals.SetReporter(new QuietReporter());
}
else
{
	Approvals.SetReporter(new DiffReporter());
}

...
private static bool IsCiCdEnvironment()
{
	string? ci = Environment.GetEnvironmentVariable("CI_ENV_SETTING");
	return !string.IsNullOrEmpty(ci);
}
```

Можно сделать это и атрибутами для compile-time, если, например, локальные тесты всегда прогоняются в дебаге, а удаленные - в релизе. Также можно указать директорию для результатов тестов, куда будут складываться .received и .approved файлы.

```csharp
#if DEBUG
	[UseReporter(typeof(DiffReporter))]
#else
	[UseReported(typeof(QuietReporter))]
#endif
	[UseApprovalSubdirectory("Results")]
public class ApprovalTest
{
	...
}
```


Давайте запустим наш пример с полями и отловим две ошибки

(живой пример)

TODO
#### Частичное сравнение и динамические данные

Иногда нам не нужна вся информация с объектов, и достаточно сравнить просто пожмножество полей. Это можно сделать при помощи анонимного объекта

```csharp
...
var subset = new
{
	largeObject.Id,
	largeObject.Name,
	CreatedAt = largeObject.CreatedAt.ToString("O")
};

string json = JsonSerializer.Serialize(subset, new JsonSerializerOptions
{
	WriteIndented = true
});

Approvals.Verify(json);
```

Еще частый случай - динамические данные в тестируемых сущностях. Иногда в тестируемую логику может проникать динамически создаваемый Guid, или DateTime. На слайде выше таким полем может быть CreatedAt. Каждый прогон теста при изменении этого поля он будет падать с новым результатом. 

В принципе можно бороться с этим при помощи DI, вводя такие сущности как IDateTimeService и IUtilities.DateTime, но они загромождают код и усложняют конструкторы, поэтому проще использовать врапперы. Они устанавливают дату и время на нужную в тесте, и вместе с тем легко сделать массовую замену строк по всему проекту, чтобы поддержать моки дат и гуидов в аппрувал тестах.

```csharp
public static class DateTimeWrapper
{
	private static DateTime? _fixedTime;
	public static DateTime UtcNow => _fixedTime ?? DateTime.UtcNow;
	public static void Set(DateTime fixedTime) => _fixedTime = fixedTime;
	public static void Reset() => _fixedTime = null;
}
```

```csharp
public static class GuidWrapper
{
	private static Guid? _fixedGuid;
	public static Guid NewGuid() => _fixedGuid ?? Guid.NewGuid();
	public static void Set(Guid fixedGuid) => _fixedGuid = fixedGuid;
	public static void Reset() => _fixedGuid = null;
}
```

```csharp
//replace DateTime.UtcNow()
var date = DateTimeWrapper.UtcNow();
// replace Guid.NewGuid()
var guid = GuidWrapper.NewGuid();
```

```csharp
public ApprovalTest()
{
	DateTimeWrapper.Set(DateTime.Parse("2025-01-01"));
	GuidWrapper.Set(new Guid("aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"));
}
```

Иногда логика может выдавать непредсказуемые результаты, для тестирования которых нужно или искать какое-то значение в динамическом списке, сравнивать по Contains или StartsWith. 

Тут нет серебряной пули, и в таких случаях нужно или каким-то образом бороться с этой случайностью в коде, приспосабливая его для того, чтобы можно было сделать выборку данных детерминированных, или писать кастомные юнит тесты уже без использования аппрувалов. 

---

#### Сценарий 2. На выходе - табличные данные.

Иногда результатом работы тестируемого метода могут быть табличные данные, которые идут в другой сервис или базу, например, DataTable для массовой bulk-вставки в базу, или csv с отчетами. 

На самом деле данные даже могут и не быть табличными, может быть стандартный json, но описывающий иерархию объектов. Например, финансовую операцию из нескольких частей, которые должны быть взаимосвязаны.  но в итоге превращаться в записи в БД. 

В этом случае представление в виде Json не даст легкой для восприятия информации

```csharp
[Test]
public class ApprovalTest
{
	// Arrange
	DataTable savedData = null;
	_repositoryMock
		.When(r => r.SaveDataTable(Arg.Is<DataTable>()))
		.Do(saved => savedData = saved);
	...
	// Act
	_service.DoSomethingAndSave();
	
	// Assert
	var json = JsonHelper.ToJson(savedData);
	Approvals.Approve(json); // ???
		// сохранение в Json не даст визуально полезной информации
}
```

Можно переписать это как

```csharp
[Test]
public class ApprovalTest
{
	// Arrange
	DataTable savedData = null;
	_repositoryMock
		.When(r => r.SaveDataTable(Arg.Is<DataTable>()))
		.Do(saved => savedData = saved);
	...
	// Act
	_service.DoSomethingAndSave();
	
	// Assert
	var table = TableFormatterHelper.ToAsciiTable(savedData);
	Approvals.Approve(table);
}
```

Где хелпер форматирует объект или dataTable в виде ascii таблицы (или, как правильно это называть, text-based table representation), например, так

```
|            | Committed  | Funded     | Funded PIK | Unfunded   | 
|----------------------------------------------------------------| 
|            | 9700000.00 | 2700000.00 | 21917.80   | 6978082.20 | 

| CustomerId | Committed  | Funded     | Funded PIK | Unfunded   | 
|----------------------------------------------------------------| 
| 2          | 6790000.00 | 1890000.00 | 15342.47   | 4884657.53 | 
| 3          | 2910000.00 | 810000.00  | 6575.34    | 2093424.66 | 
```

Или вот так

```
| Level       | Customer | ParticipationId | Expected | Actual | 
|--------------------------------------------------------------| 
| Lender      | 2        | null            | 16.66    | 16.66  | 
| Grantor     | 2        | 1011            | 6.25     | 6.25   | 
| Participant | 11       | 1011            | 3.12     | 3.12   | 
| Participant | 12       | 1011            | 1.88     | 1.88   | 
| Participant | 13       | 1011            | 1.25     | 1.25   | 
| Lender      | 3        | null            | 16.67    | 16.67  | 
| Lender      | 4        | null            | 16.67    | 16.67  | 
```

(Сам хелпер несложный, и если четыре года назад он писался вручную за час-два, то сегодня можно его сгенерировать с помощью чат гпт за 2 минуты. Код получается вполне рабочий)

Пример - это восстановленные по памяти результаты тестирования финансовой логики, которая считала и распределяла согласно определенным алгоритмам выплаты между кредиторами,  которые также могли быть связаны между собой различными условиями и отношениями и имели разные роли. В результате мы должны были получать таблицу транзакций с суммами, и оценка должна была быть проведена для всех строк в совокупности.

В этом случае 
- во-первых, при таком форматировании удобно было видеть значения полей при аппруве
- а во-вторых, при запуске diff можно было увидеть конкретное расположение поля, которое изменилось или не совпадало с ожидаемым.

(Здесь во втором примере можно заметить также  что был добавлен столбец Actual - это данные, с которыми мы сравниваем полученные в результате работы бизнес-логики значения со значениями с шага Arrange, которые, например, мог предоставить бизнес-аналитик в виде кейса.)

Описанные способы упрощают и ускоряют процесс написания ассертов для тестов, делают их более наглядными, а также позволяют скопировать результат теста для обмена этой информацией с другими членами команды в простом текстовом формате.

---

(какой-нибудь мем для расслабления)

---
####Часть 2. Рост сложности секции Arrange

Но сокращение секции Assert это только половина дела, так как секция Arrange может быть не менее сложной. Рассмотрим два сценария.

#### Сценарий 3. Комбинаторный взрыв параметров. Данные от бизнес-аналитика в excel.

В этом сценарии бизнес-аналитиком были произведены расчеты и наряду с логикой работы были предоставлены данные и формулы в excel. Формулы мы можем использовать для программирования логики, а данные хотелось бы использовать для проверки. 
стандартный вариант - это использовать  атрибуты наподобие Theory и InlineData в XUnit для подстановки множества данных и объектов в тесты.
Вообще, исторически, 

```csharp
[Theory]
[InlineData(16.66, 6.25, ...)]
[InlineData(12.66, 5.45, ...)]
public void TestTableCase1(double value1, double value2, ..., double result)
{
	...
}
```

```csharp
[Theory]
[MemberData(nameof(GetCheckTableData))]
public void TestTableCaseN(double value1, double value2, ..., double result)
{
	...
}

private static IEnumerable<object[]> GetCheckTableData()
{
	/// динамически конструируем данные для проверки в отдельном методе
	foreach(...)
	{
		yield return new object[] { value1, value2, ..., valueResult }
	}
}
```

Подход этот вполне допустимый, имеет право на жизнь, и может быть весьма удобен, когда данных не так много, но данных может быть очень много, поэтому я хочу расссмотреть немного более быстрый и экзотческий вариант, который пришелся  весьма к месту. Вариант этот взять сырые таблицы от бизнес-аналитика, и превратить их в проверяемые объекты. 

В моем случае это были те же списки транзакций, рассчитанные по формулам в excel, и так же как мы парсим json файл, можно превратить в списки объектов и csv. Но формат это сверхпростой, сверхуниверсальный, и очень удобен для обмена информацией. В csv можно превратить и excel таблицу, и выборку из базы данных. Последнее может оказаться полезным, если у нас в базе уже есть какие-то выборки объектов, которые мы можем использовать для заполнения тестовых данных. 

Написать парсер csv несложно, c этим может справиться даже нейросеть

```csharp
public static IEnumerable<Transaction> ParseCsv(string filePath)
{
	var lines = File.ReadLines(filePath);
	bool isFirstLine = true;

	foreach (var line in lines)
	{
		if (isFirstLine) // Skip header
		{
			isFirstLine = false;
			continue;
		}

		var fields = line.Split(';');
		if (fields.Length != 6) continue; // Ensure correct format

		yield return new Transaction
		{
			...
		};
	}
}
```

Но если мы хотим в C# взять сырые данные из Excel, не переводя это в формат csv, и не думая о разделителях и форматировании данных, то можно упростить получение данных при помощи FSharp

В языке F# можно напрямую парсить excel, используя соответствующий провайдер типа FSharp.ExcelProvider, и в итоге парсер может поместиться в несколько строчек.

Провайдеры типа в F# это отдельный очень мощный и удобный механизм для доступа к структурированным данным, которые обеспечивают типобезопасный доступ без необходимости ручного парсинга данных. Они являются плагинами для компилятора и генерируют типы на основе внешних данных во время компиляции.

Можно думать о них как об умных адаптерах, которые позволяют работать с excel, csv, json, базами данных итд.

```fsharp
	namespace FSharpExcelParser

	open System
	open System.Collections.Generic
	open FSharp.ExcelProvider
	open Models

	module ExcelParser =

		// Define the type provider for the Excel file
		type Excel = ExcelFile<Sample="sample.xlsx", HasHeaders=true>

		let parseExcel (filePath: string) : seq<Transaction> =
			let excel = Excel(filePath)
			excel.Data
			|> Seq.map (fun row ->
				let transaction = Transaction()
				transaction.Id <- row.Id
				transaction.ParentId <- row.ParentId
				transaction.Date <- row.Date
				transaction.TransactionType <- row.TransactionType
				transaction.Funded <- row.Funded
				transaction.Unfunded <- row.Unfunded
				transaction
			)

		// Callable from C#
		[<CompiledName("ParseExcel")>]
		let parseExcelAsList (filePath: string) : IEnumerable<Transaction> =
			parseExcel filePath :> IEnumerable<Transaction>

```

В основном проекте можно подключить и использовать F#- проект, как и любой другой.

В итоге, наш тест данных от БА, который рисковал превратиться в полотно исходных данных и огромное количество ассертов, при помощи парсинга таблиц и использования таблиц для аппрувал теста превращается в короткий и наглядный тест, входные данные которого можно посмотреть в удобном табличном редакторе, а выходные увидеть в таблично-текстовом формате. 

```csharp

```


#### Часть 3. Интеграционные тесты и исправление бага

Последний сценарий. С прода пришел баг, например, что, сумма расходится с нужной на одну копейку. Или какой-то из параметров принимает ошибочное значение. 

```
Request:
{
	"value01": 100.1123,
	"value01": 32.1211,
	...
	"value10": 45.2341
}

Response:
[
	{
		"name": "w01",
		"result01": 0.01, <----- ошибка!
		...
		"result10": 0.08
	},
	...
	{
		"name": "w10",
		"result01": 4.31,
		...
		"result10": 1.88  
	}
]
```

Это нормальная ситуация, потому что зеленые тесты и 100%-е покрытие не гарантируют отсутствие багов. Наши юнит тесты такого не предусматривали, а реальные кейсы бывают очень разнообразны. 

Такая ситуация называется "Pesticide paradox" (картинка): если используется один и тот же набор тестов, он порождает ложное чувство безопасности и рано или поздно он перестает ловить новые баги. 

Для того, чтобы поддерживать тесты в актуальном состоянии, мы должны продакшн кейс внести в набор. Часто для того, чтобы воспроизвести кейс, требуется гибридный тест, он еще не является интеграционным, так как мы не хотим стартовать для него все сервисы, но какие-то моки мы должны заменить на реальные сервисы, а для каких-то моков использовать реальный ввод, чтобы развернуть всю цепочку построения ответа. (слайд)

У нас есть текст запроса и текст результата. Фактически это готовые данные для секций Arrange и Assert. Если мы напишем аппрувал тест, то сможем быстро увидеть вход и выход, установить нужные брейкпоинты и зайти в логику.

Дополнительно, если выполнить табличное форматирование, и/или экспорт в csv, то это может помочь визуализировать результат и поделиться им с БА или QA.

```
Request:

value01  | value02 | ... | value10
----------------------------------
100.1123 | 32.1211 | ... | 45.2341

Response:

name | result01 | ... | result10
--------------------------------
w1   |     0.01 | ... |     0.08
...
w10  |     4.31 | ... |     1.88
```

### Еще инструменты, Snapshot тестирование и Verify

Verify - инструмент для снепшот-тестирования, аналогичный ApprovalTests. 
Основное отличие снепшота и апрувал теста - это необходимость первоначального просмотра и подтверждения результата при апруве. 

Снепшоты могут лучше подходить для сравнения неструктурированных данных, в то время как апрувалы лучше всего работают для JSON и таблиц.

| Аспект                  | **Снапшоты (Verify)**                                                  | **Утверждения (ApprovalTests)**                    |
| ----------------------- | ---------------------------------------------------------------------- | -------------------------------------------------- |
| **Концепция**           | Хранит **сгенерированный результат** как эталон                        | Хранит **явно утверждённый результат**             |
| **Рабочий процесс**     | Автоматически создаёт снапшот при первом запуске, затем сравнивает его | Требует ручного утверждения ожидаемого результата  |
| **Обработка изменений** | Можно автоматически обновлять снапшоты                                 | Изменения требуют явного подтверждения             |
| **Применение**          | JSON, логи, UI-рендеринг и др.                                         | Отчёты, форматированный текст, изображения и др.   |
| **Философия**           | «Если результат изменился, проверь, верно ли это.»                     | «Сначала подтверди корректность, затем используй.» |
### Возможные проблемы и минусы аппрувал тестов

- лучше всего работают для детерминированных данных и тех данных, которые можно привести к детерминированным
- требуют внимательности при начальной проверке 
- быстродействие немного медленнее, чем обычные ассерты
	- поэтому для огромной по размеру комбинации тестовых данных (например, сочетания токенов при разработке компилятора) лучше выбирать другие подходы
- рост количества текстовых файлов в репозитории
- если у тебя в руках молоток - все проблемы становятся гвоздями - стремление все даже в простых случаях делать аппрувалами
- разница настроек локализации сред выполнения - на нее тоже нужно обращать внимание. Тест может падать в контейнере и быть зеленым на локальной машине.
	- разница отображения чисел
	- разница в дате между локальной машиной и агентом CI/CD
	- итд

#### Когда использовать апрувал тесты, когда ассерты

| **Сценарий**                                                                                | **ApprovalTests** | **Классические Unit-тесты** |
| ------------------------------------------------------------------------------------------- | ----------------- | --------------------------- |
| Проверка части объекта                                                                      | ✅                 | ✅                           |
| Проверка точных значений                                                                    | ✅                 | ✅                           |
| Проверка больших объектов (JSON, таблицы, логи)                                             | ✅                 | ❌                           |
| Проверка **детерминированных** сложных данных                                               | ✅                 | ❌                           |
| Динамические значения                                                                       | ❌                 | ✅                           |
| Проверка, содержит ли объект нужные данные (вхождения строк, StartsWith, нужные байты, итд) | ❌                 | ✅                           |

### Что осталось за кадром (TBD)

Использование ApprovalTests для верификации изображений, UI и сгенерированных документов PDF.

### Выводы

Мы сегодня рассмотрели рост сложности юнит тестов с ростом сложности тестируемой логики, использование аппрувалов для уменьшения сложности и ускорения написания тестов, затронули использование табличного форматирования для удобного представления результата в diff-инструментах, посмотрели на парсинг excel при помощи F# для облегчения работы с данными секции Arrange, обсудили кейс комбинированного теста с данными продакшена.

Как у любого инструмента, у аппрувал тестов есть своя область применения, свои плюсы и минусы, а также различные библиотеки, которые помогают в работе. Мы рассмотрели ApprovalTests, но также существует и библиотека для Snapshot тестирования Verify, с похожим, но немного отличающимся подходом.

Надеюсь, что эта информация будет полезна в ежедневной работе. 
Примеры кода можно посмотреть на гитхабе по адресу...
